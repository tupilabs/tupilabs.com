---
title: 'Dissecting Jenkins console'
author: kinow
tags:
    - jenkins
    - java
time: '15:22:03'
category: blog
layout: blog
---
In this post we will dissect how the Jenkins console works. The console which we are talking about is the build execution console. It logs the output of the build steps. 

The most interesting part about the console in Jenkins, is that the web page gets updated while build steps are still producing more and more output. For someone used to web development, it is probably easy to guess that it uses some mechanism like Ajax requests to fetch the text from the server. 

But what exactly happens when that screen gets updated? Jenkins is written in Java, so if you are curious and keen to learning more about it, keep scrolling, and let's rock.

The next section is on Stapler and Jelly, if you are familiar with both tools, you can skip this section.

## Finding how Jenkins works through debugging and Jelly

Whenever I program in PHP, I always find myself using <code>var_dump</code> and <code>print_r</code> to output some variable. It is a dirty trick, and even though I have Sublime + XDebug working fine, I find it much easier to inspect my PHP code like that.

When working in Jenkins plug-ins or learning about its core, my work flow is usually debug Jenkins in Eclipse and try to guess which Java class I want by looking at the URL. Once I find it, I look for some [Jelly](http://commons.apache.org/proper/commons-jelly/) file, modify it and reload the screen to make sure that I am looking at the right place.

Jenkins uses [Stapler](https://github.com/stapler/) as web framework, and the way URL's are routed to the Java core [is intuitive](http://stapler.kohsuke.org/reference.html). In most cases, the context path can be resolved to packages and classes, or to a method in some Java class.

<code>http://localhost:8080/jenkins/job/learn-console/2/console</code>

The <core>http://localhost:8080/jenkins</core> is Jenkins main web page. Let's ignore this part and look at the rest of the URL.

<core>/job/learn-console</core> tells Jenkins which Job we want ("learn-console"). We can assume Jenkins loads this job from memory or XML by its name.

What is left is <core>/2/console</core>. The 2 is the build number and Stapler is probably binding it to some [AbstractBuild] object. The console can be a property or maybe a Jelly file. Let's take a look.

And indeed there is a *console.jelly* file there. The other console_ files, are localization files. 

So now we have a Java class and a Jelly file to start with. Let's see where it will take us.

## Console update sequence diagram


